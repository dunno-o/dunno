---
layout: post
title: Complexity classes
permalink: /TCS/complexity_classes
categories: [TCS]
---

Некоторые сложностные классы при первой встрече с ними вызывали у меня сложность с пониманием, что они значат. С **P** или **NP** все вполне интуитивно, а вот субэкспоненциальное или квазиполиномиальное время могут ставить в тупик. Итак, шпаргалка от меня. 

---

## Внутри P

### Константное время

$$O(1)$$

Здесь все очевидно: сложение двух чисел, помещающихся в регистр, проверка четности числа и так далее.

### Итерированное-логарифмическое

$$O(\log^{*}(n))$$

Определение итерированного логарифма см. математический анализ.

### Логарифмическое время = DLOGTIME

$$O(\log{n})$$

*Напоминание:* \\(DTIME(f(n))\\) - множество языков разрешимых детерминированной машиной Тьюринга за время \\(f(n)\\).

Тогда \\(DLOGTIME = DTIME(\log{(n)})\\)

Примерами будет \\(\log{n^3}\\), бинарный поиск.


### Полилогарифмическое время

Языки разрешимые на ДМТ(детерминированная машина Тьюринга) за время \\(poly(\log{n})\\)

Пример, \\(\log^2{n}\\)

### Сублинейное время

$$O(n^k) \ \textit{при} \ k \in (0, 1)$$

Пример: \\(n^{1/2}\\)

### Линейное время

$$O(n)$$

Это тоже всем известная штука. Линейный поиск все дела.

### Полиномиальное время = PTIME

$$poly(n) = 2^{O(\log{n})}$$

Важнейший сложностной класс, проблемы которого считаются "быстро" решаемыми. Слово "быстро" здесь довольно коварное, так как скрываться за ним может как линейное или квадратичное время, так и что-то вроде \\(O(n^{10000})\\)

## Вне P

### Квазиполиномиальное время

$$QP = DTIME(2^{poly(\log{n})})$$

### Субэкспоненциальное время

$$SUBEXPTIME = O(2^{n^{\epsilon}}) \ \forall \epsilon > 0 = 2^{\bar o(n)}$$


### Экспоненциальное время

$$EXPTIME = 2^{poly(n)}$$

## Псевдополиномиальные алгоритмы

Некоторые задачи могут иметь алгоритм решения показывающий полиномиальный рост в зависимости от условий задачи. 

Например, известная задача об укладке рюкзака. Решение этой задачи динамическим программированием имеет сложность \\(O(n \cdot W)\\), где \\(W\\) - максимальный вес. 

Несмотря на то, что выглядит эта сложность как полином от n, под \\(W\\) вообще-то может скрываться экспоненциально большое по сравнению с n число из-за чего алгоритм перестанет быть полиномиальным. В таких случаях алгоритм называют псевдополиномиальным. 

**Определение**

Алгоритм имеет псевдополиномиальную сложность, если он работает за время полиномиальное от числового значения входа(унарной записи числа), а не за полином от *длины двоичной записи входа*, что как раз называется полиномиальным временем.
